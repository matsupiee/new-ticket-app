# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

type Account {
  accessToken: String
  accessTokenExpiresAt: DateTime
  accountId: String!
  createdAt: DateTime!
  id: ID!
  idToken: String
  password: String
  providerId: String!
  refreshToken: String
  refreshTokenExpiresAt: DateTime
  scope: String
  updatedAt: DateTime!
  user: User!
  userId: String!
}

type AccountConnection {
  edges: [AccountEdge!]!
  nodes: [Account!]!
  pageInfo: AccountPageInfo!
  totalCount: Int!
}

type AccountEdge {
  cursor: String!
  node: Account!
}

input AccountListRelationFilter {
  every: AccountWhereInput
  none: AccountWhereInput
  some: AccountWhereInput
}

input AccountOrderByRelationAggregateInput {
  _count: SortOrder
}

input AccountOrderByWithRelationInput {
  accessToken: SortOrderInput
  accessTokenExpiresAt: SortOrderInput
  accountId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  idToken: SortOrderInput
  password: SortOrderInput
  providerId: SortOrder
  refreshToken: SortOrderInput
  refreshTokenExpiresAt: SortOrderInput
  scope: SortOrderInput
  updatedAt: SortOrder
  user: UserOrderByWithRelationInput
  userId: SortOrder
}

type AccountPageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

input AccountWhereInput {
  AND: [AccountWhereInput!]
  NOT: [AccountWhereInput!]
  OR: [AccountWhereInput!]
  accessToken: StringNullableFilter
  accessTokenExpiresAt: DateTimeNullableFilter
  accountId: StringFilter
  createdAt: DateTimeFilter
  id: StringFilter
  idToken: StringNullableFilter
  password: StringNullableFilter
  providerId: StringFilter
  refreshToken: StringNullableFilter
  refreshTokenExpiresAt: DateTimeNullableFilter
  scope: StringNullableFilter
  updatedAt: DateTimeFilter
  user: UserScalarRelationFilter
  userId: StringFilter
}

enum AdmissionMethod {
  ADMIN_DEVICE
  CUSTOMER_DEVICE_BUTTON
  QR_CODE
}

type Artist {
  createdAt: DateTime!
  description: String
  favorites: [FavoriteArtist!]
  id: ID!
  name: String!
  profileImageUrl: String
  stageArtists: [StageArtist!]
  twitterAccount: String
  updatedAt: DateTime!
}

type ArtistConnection {
  edges: [ArtistEdge!]!
  nodes: [Artist!]!
  pageInfo: ArtistPageInfo!
  totalCount: Int!
}

type ArtistEdge {
  cursor: String!
  node: Artist!
}

input ArtistOrderByWithRelationInput {
  createdAt: SortOrder
  description: SortOrderInput
  favorites: FavoriteArtistOrderByRelationAggregateInput
  id: SortOrder
  name: SortOrder
  profileImageUrl: SortOrderInput
  stageArtists: StageArtistOrderByRelationAggregateInput
  twitterAccount: SortOrderInput
  updatedAt: SortOrder
}

type ArtistPageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

input ArtistScalarRelationFilter {
  is: ArtistWhereInput
  isNot: ArtistWhereInput
}

input ArtistWhereInput {
  AND: [ArtistWhereInput!]
  NOT: [ArtistWhereInput!]
  OR: [ArtistWhereInput!]
  createdAt: DateTimeFilter
  description: StringNullableFilter
  favorites: FavoriteArtistListRelationFilter
  id: StringFilter
  name: StringFilter
  profileImageUrl: StringNullableFilter
  stageArtists: StageArtistListRelationFilter
  twitterAccount: StringNullableFilter
  updatedAt: DateTimeFilter
}

type AvailablePaymentMethod {
  createdAt: DateTime!
  id: ID!
  paymentMethod: PaymentMethodType!
  saleSchedule: SaleSchedule!
  saleScheduleId: String!
  updatedAt: DateTime!
}

type AvailablePaymentMethodConnection {
  edges: [AvailablePaymentMethodEdge!]!
  nodes: [AvailablePaymentMethod!]!
  pageInfo: AvailablePaymentMethodPageInfo!
  totalCount: Int!
}

type AvailablePaymentMethodEdge {
  cursor: String!
  node: AvailablePaymentMethod!
}

input AvailablePaymentMethodListRelationFilter {
  every: AvailablePaymentMethodWhereInput
  none: AvailablePaymentMethodWhereInput
  some: AvailablePaymentMethodWhereInput
}

input AvailablePaymentMethodOrderByRelationAggregateInput {
  _count: SortOrder
}

input AvailablePaymentMethodOrderByWithRelationInput {
  createdAt: SortOrder
  id: SortOrder
  paymentMethod: SortOrder
  saleSchedule: SaleScheduleOrderByWithRelationInput
  saleScheduleId: SortOrder
  updatedAt: SortOrder
}

type AvailablePaymentMethodPageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

input AvailablePaymentMethodWhereInput {
  AND: [AvailablePaymentMethodWhereInput!]
  NOT: [AvailablePaymentMethodWhereInput!]
  OR: [AvailablePaymentMethodWhereInput!]
  createdAt: DateTimeFilter
  id: StringFilter
  paymentMethod: EnumPaymentMethodTypeFilter
  saleSchedule: SaleScheduleScalarRelationFilter
  saleScheduleId: StringFilter
  updatedAt: DateTimeFilter
}

type BankAccount {
  accountHolder: String!
  accountNumber: String!
  accountType: BankAccountType!
  bankCode: String!
  bankName: String!
  branchCode: String!
  branchName: String!
  createdAt: DateTime!
  eventOrganizer: EventOrganizer!
  eventOrganizerId: String!
  id: ID!
  isDefault: Boolean!
  updatedAt: DateTime!
}

type BankAccountConnection {
  edges: [BankAccountEdge!]!
  nodes: [BankAccount!]!
  pageInfo: BankAccountPageInfo!
  totalCount: Int!
}

type BankAccountEdge {
  cursor: String!
  node: BankAccount!
}

input BankAccountListRelationFilter {
  every: BankAccountWhereInput
  none: BankAccountWhereInput
  some: BankAccountWhereInput
}

input BankAccountOrderByRelationAggregateInput {
  _count: SortOrder
}

input BankAccountOrderByWithRelationInput {
  accountHolder: SortOrder
  accountNumber: SortOrder
  accountType: SortOrder
  bankCode: SortOrder
  bankName: SortOrder
  branchCode: SortOrder
  branchName: SortOrder
  createdAt: SortOrder
  eventOrganizer: EventOrganizerOrderByWithRelationInput
  eventOrganizerId: SortOrder
  id: SortOrder
  isDefault: SortOrder
  updatedAt: SortOrder
}

type BankAccountPageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

enum BankAccountType {
  CHECKING
  SAVINGS
}

input BankAccountWhereInput {
  AND: [BankAccountWhereInput!]
  NOT: [BankAccountWhereInput!]
  OR: [BankAccountWhereInput!]
  accountHolder: StringFilter
  accountNumber: StringFilter
  accountType: EnumBankAccountTypeFilter
  bankCode: StringFilter
  bankName: StringFilter
  branchCode: StringFilter
  branchName: StringFilter
  createdAt: DateTimeFilter
  eventOrganizer: EventOrganizerScalarRelationFilter
  eventOrganizerId: StringFilter
  id: StringFilter
  isDefault: BoolFilter
  updatedAt: DateTimeFilter
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input DateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input EnumAdmissionMethodFilter {
  equals: AdmissionMethod
  in: [AdmissionMethod!]
  not: NestedEnumAdmissionMethodFilter
  notIn: [AdmissionMethod!]
}

input EnumBankAccountTypeFilter {
  equals: BankAccountType
  in: [BankAccountType!]
  not: NestedEnumBankAccountTypeFilter
  notIn: [BankAccountType!]
}

input EnumEventPublishStatusFilter {
  equals: EventPublishStatus
  in: [EventPublishStatus!]
  not: NestedEnumEventPublishStatusFilter
  notIn: [EventPublishStatus!]
}

input EnumLotteryModeNullableFilter {
  equals: LotteryMode
  in: [LotteryMode!]
  not: NestedEnumLotteryModeNullableFilter
  notIn: [LotteryMode!]
}

input EnumPaymentMethodTypeFilter {
  equals: PaymentMethodType
  in: [PaymentMethodType!]
  not: NestedEnumPaymentMethodTypeFilter
  notIn: [PaymentMethodType!]
}

input EnumPaymentProviderFilter {
  equals: PaymentProvider
  in: [PaymentProvider!]
  not: NestedEnumPaymentProviderFilter
  notIn: [PaymentProvider!]
}

input EnumPaymentStatusFilter {
  equals: PaymentStatus
  in: [PaymentStatus!]
  not: NestedEnumPaymentStatusFilter
  notIn: [PaymentStatus!]
}

input EnumSaleSchedulePublishStatusFilter {
  equals: SaleSchedulePublishStatus
  in: [SaleSchedulePublishStatus!]
  not: NestedEnumSaleSchedulePublishStatusFilter
  notIn: [SaleSchedulePublishStatus!]
}

input EnumSaleTypeFilter {
  equals: SaleType
  in: [SaleType!]
  not: NestedEnumSaleTypeFilter
  notIn: [SaleType!]
}

input EnumSeatTypeFilter {
  equals: SeatType
  in: [SeatType!]
  not: NestedEnumSeatTypeFilter
  notIn: [SeatType!]
}

input EnumTicketApplicationStatusFilter {
  equals: TicketApplicationStatus
  in: [TicketApplicationStatus!]
  not: NestedEnumTicketApplicationStatusFilter
  notIn: [TicketApplicationStatus!]
}

input EnumTicketTransferPolicyFilter {
  equals: TicketTransferPolicy
  in: [TicketTransferPolicy!]
  not: NestedEnumTicketTransferPolicyFilter
  notIn: [TicketTransferPolicy!]
}

input EnumUserRoleFilter {
  equals: UserRole
  in: [UserRole!]
  not: NestedEnumUserRoleFilter
  notIn: [UserRole!]
}

type Event {
  createdAt: DateTime!
  description: String!
  eventOrganizer: EventOrganizer!
  eventOrganizerId: String!
  favoriteEvents: [FavoriteEvent!]
  featuredEvent: FeaturedEvent
  id: ID!
  inquiry: String!
  isDisplayedInTop: Boolean!
  isTokuteiKogyo: Boolean!
  lineThumbnailUrl: String
  name: String!
  publishAt: DateTime
  publishStatus: EventPublishStatus!
  saleSchedules: [SaleSchedule!]
  stages: [Stage!]
  thumbnailUrls: [String!]
  updatedAt: DateTime!
}

type EventConnection {
  edges: [EventEdge!]!
  nodes: [Event!]!
  pageInfo: EventPageInfo!
  totalCount: Int!
}

input EventCreateInput {
  description: String!
  eventOrganizerId: String!
  inquiry: String!
  lineThumbnailUrl: String
  name: String!
  stages: [StageInput!]!
  thumbnailUrls: [String!]
}

type EventCreatePayload {
  event: Event!
}

type EventDeletePayload {
  event: Event!
}

type EventEdge {
  cursor: String!
  node: Event!
}

input EventListRelationFilter {
  every: EventWhereInput
  none: EventWhereInput
  some: EventWhereInput
}

input EventOrderByRelationAggregateInput {
  _count: SortOrder
}

input EventOrderByWithRelationInput {
  createdAt: SortOrder
  description: SortOrder
  eventOrganizer: EventOrganizerOrderByWithRelationInput
  eventOrganizerId: SortOrder
  favoriteEvents: FavoriteEventOrderByRelationAggregateInput
  featuredEvent: FeaturedEventOrderByWithRelationInput
  id: SortOrder
  inquiry: SortOrder
  isDisplayedInTop: SortOrder
  isTokuteiKogyo: SortOrder
  lineThumbnailUrl: SortOrderInput
  name: SortOrder
  publishAt: SortOrderInput
  publishStatus: SortOrder
  saleSchedules: SaleScheduleOrderByRelationAggregateInput
  stages: StageOrderByRelationAggregateInput
  thumbnailUrls: SortOrder
  updatedAt: SortOrder
}

type EventOrganizer {
  bankAccounts: [BankAccount!]
  createdAt: DateTime!
  eventOrganizerFeatures: [EventOrganizerFeature!]
  eventOrganizerReferrers: [EventOrganizerReferrer!]
  events: [Event!]
  id: ID!
  inquiryEmail: String!
  inquirySubject: String!
  name: String!
  notifyEmail: String
  notifySlackWebhookUrl: String
  ticketTypeFeeDistributions: [TicketTypeFeeDistribution!]
  ticketTypePriceDistributions: [TicketTypePriceDistribution!]
  updatedAt: DateTime!
  user: User!
  userId: String!
}

type EventOrganizerConnection {
  edges: [EventOrganizerEdge!]!
  nodes: [EventOrganizer!]!
  pageInfo: EventOrganizerPageInfo!
  totalCount: Int!
}

type EventOrganizerEdge {
  cursor: String!
  node: EventOrganizer!
}

type EventOrganizerFeature {
  createdAt: DateTime!
  enabled: Boolean!
  eventOrganizer: EventOrganizer!
  eventOrganizerId: String!
  id: ID!
  key: String!
  updatedAt: DateTime!
}

type EventOrganizerFeatureConnection {
  edges: [EventOrganizerFeatureEdge!]!
  nodes: [EventOrganizerFeature!]!
  pageInfo: EventOrganizerFeaturePageInfo!
  totalCount: Int!
}

type EventOrganizerFeatureEdge {
  cursor: String!
  node: EventOrganizerFeature!
}

input EventOrganizerFeatureListRelationFilter {
  every: EventOrganizerFeatureWhereInput
  none: EventOrganizerFeatureWhereInput
  some: EventOrganizerFeatureWhereInput
}

input EventOrganizerFeatureOrderByRelationAggregateInput {
  _count: SortOrder
}

input EventOrganizerFeatureOrderByWithRelationInput {
  createdAt: SortOrder
  enabled: SortOrder
  eventOrganizer: EventOrganizerOrderByWithRelationInput
  eventOrganizerId: SortOrder
  id: SortOrder
  key: SortOrder
  updatedAt: SortOrder
}

type EventOrganizerFeaturePageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

input EventOrganizerFeatureWhereInput {
  AND: [EventOrganizerFeatureWhereInput!]
  NOT: [EventOrganizerFeatureWhereInput!]
  OR: [EventOrganizerFeatureWhereInput!]
  createdAt: DateTimeFilter
  enabled: BoolFilter
  eventOrganizer: EventOrganizerScalarRelationFilter
  eventOrganizerId: StringFilter
  id: StringFilter
  key: StringFilter
  updatedAt: DateTimeFilter
}

input EventOrganizerListRelationFilter {
  every: EventOrganizerWhereInput
  none: EventOrganizerWhereInput
  some: EventOrganizerWhereInput
}

input EventOrganizerOrderByRelationAggregateInput {
  _count: SortOrder
}

input EventOrganizerOrderByWithRelationInput {
  bankAccounts: BankAccountOrderByRelationAggregateInput
  createdAt: SortOrder
  eventOrganizerFeatures: EventOrganizerFeatureOrderByRelationAggregateInput
  eventOrganizerReferrers: EventOrganizerReferrerOrderByRelationAggregateInput
  events: EventOrderByRelationAggregateInput
  id: SortOrder
  inquiryEmail: SortOrder
  inquirySubject: SortOrder
  name: SortOrder
  notifyEmail: SortOrderInput
  notifySlackWebhookUrl: SortOrderInput
  ticketTypeFeeDistributions: TicketTypeFeeDistributionOrderByRelationAggregateInput
  ticketTypePriceDistributions: TicketTypePriceDistributionOrderByRelationAggregateInput
  updatedAt: SortOrder
  user: UserOrderByWithRelationInput
  userId: SortOrder
}

type EventOrganizerPageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

type EventOrganizerReferrer {
  createdAt: DateTime!
  eventOrganizer: EventOrganizer!
  eventOrganizerId: String!
  id: ID!
  name: String!
  referrerSource: String!
  updatedAt: DateTime!
}

type EventOrganizerReferrerConnection {
  edges: [EventOrganizerReferrerEdge!]!
  nodes: [EventOrganizerReferrer!]!
  pageInfo: EventOrganizerReferrerPageInfo!
  totalCount: Int!
}

type EventOrganizerReferrerEdge {
  cursor: String!
  node: EventOrganizerReferrer!
}

input EventOrganizerReferrerListRelationFilter {
  every: EventOrganizerReferrerWhereInput
  none: EventOrganizerReferrerWhereInput
  some: EventOrganizerReferrerWhereInput
}

input EventOrganizerReferrerOrderByRelationAggregateInput {
  _count: SortOrder
}

input EventOrganizerReferrerOrderByWithRelationInput {
  createdAt: SortOrder
  eventOrganizer: EventOrganizerOrderByWithRelationInput
  eventOrganizerId: SortOrder
  id: SortOrder
  name: SortOrder
  referrerSource: SortOrder
  updatedAt: SortOrder
}

type EventOrganizerReferrerPageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

input EventOrganizerReferrerWhereInput {
  AND: [EventOrganizerReferrerWhereInput!]
  NOT: [EventOrganizerReferrerWhereInput!]
  OR: [EventOrganizerReferrerWhereInput!]
  createdAt: DateTimeFilter
  eventOrganizer: EventOrganizerScalarRelationFilter
  eventOrganizerId: StringFilter
  id: StringFilter
  name: StringFilter
  referrerSource: StringFilter
  updatedAt: DateTimeFilter
}

input EventOrganizerScalarRelationFilter {
  is: EventOrganizerWhereInput
  isNot: EventOrganizerWhereInput
}

input EventOrganizerWhereInput {
  AND: [EventOrganizerWhereInput!]
  NOT: [EventOrganizerWhereInput!]
  OR: [EventOrganizerWhereInput!]
  bankAccounts: BankAccountListRelationFilter
  createdAt: DateTimeFilter
  eventOrganizerFeatures: EventOrganizerFeatureListRelationFilter
  eventOrganizerReferrers: EventOrganizerReferrerListRelationFilter
  events: EventListRelationFilter
  id: StringFilter
  inquiryEmail: StringFilter
  inquirySubject: StringFilter
  name: StringFilter
  notifyEmail: StringNullableFilter
  notifySlackWebhookUrl: StringNullableFilter
  ticketTypeFeeDistributions: TicketTypeFeeDistributionListRelationFilter
  ticketTypePriceDistributions: TicketTypePriceDistributionListRelationFilter
  updatedAt: DateTimeFilter
  user: UserScalarRelationFilter
  userId: StringFilter
}

type EventPageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

enum EventPublishStatus {
  PUBLISHED
  UNPUBLISHED
}

input EventScalarRelationFilter {
  is: EventWhereInput
  isNot: EventWhereInput
}

input EventUpdateInput {
  description: String
  id: ID!
  inquiry: String
  lineThumbnailUrl: String
  name: String
  thumbnailUrls: [String!]
}

type EventUpdatePayload {
  event: Event!
}

input EventWhereInput {
  AND: [EventWhereInput!]
  NOT: [EventWhereInput!]
  OR: [EventWhereInput!]
  createdAt: DateTimeFilter
  description: StringFilter
  eventOrganizer: EventOrganizerScalarRelationFilter
  eventOrganizerId: StringFilter
  favoriteEvents: FavoriteEventListRelationFilter
  featuredEvent: FeaturedEventNullableScalarRelationFilter
  id: StringFilter
  inquiry: StringFilter
  isDisplayedInTop: BoolFilter
  isTokuteiKogyo: BoolFilter
  lineThumbnailUrl: StringNullableFilter
  name: StringFilter
  publishAt: DateTimeNullableFilter
  publishStatus: EnumEventPublishStatusFilter
  saleSchedules: SaleScheduleListRelationFilter
  stages: StageListRelationFilter
  thumbnailUrls: StringNullableListFilter
  updatedAt: DateTimeFilter
}

type FavoriteArtist {
  artist: Artist!
  artistId: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  user: User!
  userId: String!
}

input FavoriteArtistListRelationFilter {
  every: FavoriteArtistWhereInput
  none: FavoriteArtistWhereInput
  some: FavoriteArtistWhereInput
}

input FavoriteArtistOrderByRelationAggregateInput {
  _count: SortOrder
}

input FavoriteArtistWhereInput {
  AND: [FavoriteArtistWhereInput!]
  NOT: [FavoriteArtistWhereInput!]
  OR: [FavoriteArtistWhereInput!]
  artist: ArtistScalarRelationFilter
  artistId: StringFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  user: UserScalarRelationFilter
  userId: StringFilter
}

type FavoriteEvent {
  createdAt: DateTime!
  event: Event!
  eventId: String!
  updatedAt: DateTime!
  user: User!
  userId: String!
}

input FavoriteEventListRelationFilter {
  every: FavoriteEventWhereInput
  none: FavoriteEventWhereInput
  some: FavoriteEventWhereInput
}

input FavoriteEventOrderByRelationAggregateInput {
  _count: SortOrder
}

input FavoriteEventWhereInput {
  AND: [FavoriteEventWhereInput!]
  NOT: [FavoriteEventWhereInput!]
  OR: [FavoriteEventWhereInput!]
  createdAt: DateTimeFilter
  event: EventScalarRelationFilter
  eventId: StringFilter
  updatedAt: DateTimeFilter
  user: UserScalarRelationFilter
  userId: StringFilter
}

type FeaturedEvent {
  createdAt: DateTime!
  endAt: DateTime
  event: Event!
  eventId: String!
  id: ID!
  publishAt: DateTime
  sortOrder: Int!
  updatedAt: DateTime!
}

type FeaturedEventConnection {
  edges: [FeaturedEventEdge!]!
  nodes: [FeaturedEvent!]!
  pageInfo: FeaturedEventPageInfo!
  totalCount: Int!
}

type FeaturedEventEdge {
  cursor: String!
  node: FeaturedEvent!
}

input FeaturedEventNullableScalarRelationFilter {
  is: FeaturedEventWhereInput
  isNot: FeaturedEventWhereInput
}

input FeaturedEventOrderByWithRelationInput {
  createdAt: SortOrder
  endAt: SortOrderInput
  event: EventOrderByWithRelationInput
  eventId: SortOrder
  id: SortOrder
  publishAt: SortOrderInput
  sortOrder: SortOrder
  updatedAt: SortOrder
}

type FeaturedEventPageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

input FeaturedEventWhereInput {
  AND: [FeaturedEventWhereInput!]
  NOT: [FeaturedEventWhereInput!]
  OR: [FeaturedEventWhereInput!]
  createdAt: DateTimeFilter
  endAt: DateTimeNullableFilter
  event: EventScalarRelationFilter
  eventId: StringFilter
  id: StringFilter
  publishAt: DateTimeNullableFilter
  sortOrder: IntFilter
  updatedAt: DateTimeFilter
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

enum LotteryMode {
  AUTO
  MANUAL
}

type Mutation {
  """イベントを作成する"""
  eventCreate(input: EventCreateInput!): EventCreatePayload!

  """イベントを削除する"""
  eventDelete(id: ID!): EventDeletePayload!

  """イベントを更新する"""
  eventUpdate(input: EventUpdateInput!): EventUpdatePayload!

  """販売スケジュールを作成する"""
  saleScheduleCreate(input: SaleScheduleCreateInput!): SaleScheduleCreatePayload!

  """販売スケジュールを更新する"""
  saleScheduleUpdate(input: SaleScheduleUpdateInput!): SaleScheduleUpdatePayload!

  """イベントのステージ情報を更新する"""
  stagesUpdate(input: StagesUpdateInput!): StagesUpdatePayload!

  """チケットタイプを更新する"""
  ticketTypeUpdate(input: TicketTypeUpdateInput!): TicketTypeUpdatePayload!
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedDateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input NestedEnumAdmissionMethodFilter {
  equals: AdmissionMethod
  in: [AdmissionMethod!]
  not: NestedEnumAdmissionMethodFilter
  notIn: [AdmissionMethod!]
}

input NestedEnumBankAccountTypeFilter {
  equals: BankAccountType
  in: [BankAccountType!]
  not: NestedEnumBankAccountTypeFilter
  notIn: [BankAccountType!]
}

input NestedEnumEventPublishStatusFilter {
  equals: EventPublishStatus
  in: [EventPublishStatus!]
  not: NestedEnumEventPublishStatusFilter
  notIn: [EventPublishStatus!]
}

input NestedEnumLotteryModeNullableFilter {
  equals: LotteryMode
  in: [LotteryMode!]
  not: NestedEnumLotteryModeNullableFilter
  notIn: [LotteryMode!]
}

input NestedEnumPaymentMethodTypeFilter {
  equals: PaymentMethodType
  in: [PaymentMethodType!]
  not: NestedEnumPaymentMethodTypeFilter
  notIn: [PaymentMethodType!]
}

input NestedEnumPaymentProviderFilter {
  equals: PaymentProvider
  in: [PaymentProvider!]
  not: NestedEnumPaymentProviderFilter
  notIn: [PaymentProvider!]
}

input NestedEnumPaymentStatusFilter {
  equals: PaymentStatus
  in: [PaymentStatus!]
  not: NestedEnumPaymentStatusFilter
  notIn: [PaymentStatus!]
}

input NestedEnumSaleSchedulePublishStatusFilter {
  equals: SaleSchedulePublishStatus
  in: [SaleSchedulePublishStatus!]
  not: NestedEnumSaleSchedulePublishStatusFilter
  notIn: [SaleSchedulePublishStatus!]
}

input NestedEnumSaleTypeFilter {
  equals: SaleType
  in: [SaleType!]
  not: NestedEnumSaleTypeFilter
  notIn: [SaleType!]
}

input NestedEnumSeatTypeFilter {
  equals: SeatType
  in: [SeatType!]
  not: NestedEnumSeatTypeFilter
  notIn: [SeatType!]
}

input NestedEnumTicketApplicationStatusFilter {
  equals: TicketApplicationStatus
  in: [TicketApplicationStatus!]
  not: NestedEnumTicketApplicationStatusFilter
  notIn: [TicketApplicationStatus!]
}

input NestedEnumTicketTransferPolicyFilter {
  equals: TicketTransferPolicy
  in: [TicketTransferPolicy!]
  not: NestedEnumTicketTransferPolicyFilter
  notIn: [TicketTransferPolicy!]
}

input NestedEnumUserRoleFilter {
  equals: UserRole
  in: [UserRole!]
  not: NestedEnumUserRoleFilter
  notIn: [UserRole!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

enum NullsOrder {
  first
  last
}

type Payment {
  authorizedAt: DateTime
  capturedAt: DateTime
  cardId: String
  createdAt: DateTime!
  externalId: String
  failedAt: DateTime
  failureReason: String
  id: ID!
  paymentCard: PaymentCard
  paymentItems: [PaymentItem!]
  paymentMethod: PaymentMethodType!
  status: PaymentStatus!
  ticketApplication: TicketApplication!
  ticketApplicationId: String!
  totalPaymentAmount: Int!
  updatedAt: DateTime!
}

type PaymentCard {
  cardBrand: String!
  cardLast4: String!
  cardToken: String!
  createdAt: DateTime!
  expiryMonth: Int!
  expiryYear: Int!
  id: ID!
  isDefault: Boolean!
  payments: [Payment!]
  provider: PaymentProvider!
  updatedAt: DateTime!
  user: User!
  userId: String!
}

type PaymentCardConnection {
  edges: [PaymentCardEdge!]!
  nodes: [PaymentCard!]!
  pageInfo: PaymentCardPageInfo!
  totalCount: Int!
}

type PaymentCardEdge {
  cursor: String!
  node: PaymentCard!
}

input PaymentCardListRelationFilter {
  every: PaymentCardWhereInput
  none: PaymentCardWhereInput
  some: PaymentCardWhereInput
}

input PaymentCardNullableScalarRelationFilter {
  is: PaymentCardWhereInput
  isNot: PaymentCardWhereInput
}

input PaymentCardOrderByRelationAggregateInput {
  _count: SortOrder
}

input PaymentCardOrderByWithRelationInput {
  cardBrand: SortOrder
  cardLast4: SortOrder
  cardToken: SortOrder
  createdAt: SortOrder
  expiryMonth: SortOrder
  expiryYear: SortOrder
  id: SortOrder
  isDefault: SortOrder
  payments: PaymentOrderByRelationAggregateInput
  provider: SortOrder
  updatedAt: SortOrder
  user: UserOrderByWithRelationInput
  userId: SortOrder
}

type PaymentCardPageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

input PaymentCardWhereInput {
  AND: [PaymentCardWhereInput!]
  NOT: [PaymentCardWhereInput!]
  OR: [PaymentCardWhereInput!]
  cardBrand: StringFilter
  cardLast4: StringFilter
  cardToken: StringFilter
  createdAt: DateTimeFilter
  expiryMonth: IntFilter
  expiryYear: IntFilter
  id: StringFilter
  isDefault: BoolFilter
  payments: PaymentListRelationFilter
  provider: EnumPaymentProviderFilter
  updatedAt: DateTimeFilter
  user: UserScalarRelationFilter
  userId: StringFilter
}

type PaymentConnection {
  edges: [PaymentEdge!]!
  nodes: [Payment!]!
  pageInfo: PaymentPageInfo!
  totalCount: Int!
}

type PaymentEdge {
  cursor: String!
  node: Payment!
}

type PaymentItem {
  createdAt: DateTime!
  id: ID!
  payment: Payment!
  paymentId: String!
  ticketApplicationItem: TicketApplicationItem!
  ticketApplicationItemId: String!
  updatedAt: DateTime!
}

type PaymentItemConnection {
  edges: [PaymentItemEdge!]!
  nodes: [PaymentItem!]!
  pageInfo: PaymentItemPageInfo!
  totalCount: Int!
}

type PaymentItemEdge {
  cursor: String!
  node: PaymentItem!
}

input PaymentItemListRelationFilter {
  every: PaymentItemWhereInput
  none: PaymentItemWhereInput
  some: PaymentItemWhereInput
}

input PaymentItemOrderByRelationAggregateInput {
  _count: SortOrder
}

input PaymentItemOrderByWithRelationInput {
  createdAt: SortOrder
  id: SortOrder
  payment: PaymentOrderByWithRelationInput
  paymentId: SortOrder
  ticketApplicationItem: TicketApplicationItemOrderByWithRelationInput
  ticketApplicationItemId: SortOrder
  updatedAt: SortOrder
}

type PaymentItemPageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

input PaymentItemWhereInput {
  AND: [PaymentItemWhereInput!]
  NOT: [PaymentItemWhereInput!]
  OR: [PaymentItemWhereInput!]
  createdAt: DateTimeFilter
  id: StringFilter
  payment: PaymentScalarRelationFilter
  paymentId: StringFilter
  ticketApplicationItem: TicketApplicationItemScalarRelationFilter
  ticketApplicationItemId: StringFilter
  updatedAt: DateTimeFilter
}

input PaymentListRelationFilter {
  every: PaymentWhereInput
  none: PaymentWhereInput
  some: PaymentWhereInput
}

enum PaymentMethodType {
  CARD
  KONBINI
}

input PaymentOrderByRelationAggregateInput {
  _count: SortOrder
}

input PaymentOrderByWithRelationInput {
  authorizedAt: SortOrderInput
  capturedAt: SortOrderInput
  cardId: SortOrderInput
  createdAt: SortOrder
  externalId: SortOrderInput
  failedAt: SortOrderInput
  failureReason: SortOrderInput
  id: SortOrder
  paymentCard: PaymentCardOrderByWithRelationInput
  paymentItems: PaymentItemOrderByRelationAggregateInput
  paymentMethod: SortOrder
  status: SortOrder
  ticketApplication: TicketApplicationOrderByWithRelationInput
  ticketApplicationId: SortOrder
  totalPaymentAmount: SortOrder
  updatedAt: SortOrder
}

type PaymentPageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

enum PaymentProvider {
  GMO
  RAKUTEN
}

input PaymentScalarRelationFilter {
  is: PaymentWhereInput
  isNot: PaymentWhereInput
}

enum PaymentStatus {
  AUTHORIZED
  CANCELLED
  CAPTURED
  FAILED
  PENDING
  REFUNDED
}

input PaymentWhereInput {
  AND: [PaymentWhereInput!]
  NOT: [PaymentWhereInput!]
  OR: [PaymentWhereInput!]
  authorizedAt: DateTimeNullableFilter
  capturedAt: DateTimeNullableFilter
  cardId: StringNullableFilter
  createdAt: DateTimeFilter
  externalId: StringNullableFilter
  failedAt: DateTimeNullableFilter
  failureReason: StringNullableFilter
  id: StringFilter
  paymentCard: PaymentCardNullableScalarRelationFilter
  paymentItems: PaymentItemListRelationFilter
  paymentMethod: EnumPaymentMethodTypeFilter
  status: EnumPaymentStatusFilter
  ticketApplication: TicketApplicationScalarRelationFilter
  ticketApplicationId: StringFilter
  totalPaymentAmount: IntFilter
  updatedAt: DateTimeFilter
}

type Query {
  """アカウントを1件取得する"""
  account(id: ID!): Account

  """アカウントを複数取得する"""
  accounts(after: String, before: String, first: Int, last: Int, orderBy: [AccountOrderByWithRelationInput!], where: AccountWhereInput): AccountConnection!

  """アーティストを1件取得する"""
  artist(id: ID!): Artist

  """アーティストを複数取得する"""
  artists(after: String, before: String, first: Int, last: Int, orderBy: [ArtistOrderByWithRelationInput!], where: ArtistWhereInput): ArtistConnection!

  """利用可能な支払い方法を1件取得する"""
  availablePaymentMethod(id: ID!): AvailablePaymentMethod

  """利用可能な支払い方法を複数取得する"""
  availablePaymentMethods(after: String, before: String, first: Int, last: Int, orderBy: [AvailablePaymentMethodOrderByWithRelationInput!], where: AvailablePaymentMethodWhereInput): AvailablePaymentMethodConnection!

  """銀行口座を1件取得する"""
  bankAccount(id: ID!): BankAccount

  """銀行口座を複数取得する"""
  bankAccounts(after: String, before: String, first: Int, last: Int, orderBy: [BankAccountOrderByWithRelationInput!], where: BankAccountWhereInput): BankAccountConnection!

  """イベントを1件取得する"""
  event(id: ID!): Event

  """イベント主催者を1件取得する"""
  eventOrganizer(id: ID!): EventOrganizer

  """イベント主催者機能を1件取得する"""
  eventOrganizerFeature(id: ID!): EventOrganizerFeature

  """イベント主催者機能を複数取得する"""
  eventOrganizerFeatures(after: String, before: String, first: Int, last: Int, orderBy: [EventOrganizerFeatureOrderByWithRelationInput!], where: EventOrganizerFeatureWhereInput): EventOrganizerFeatureConnection!

  """イベント主催者紹介者を1件取得する"""
  eventOrganizerReferrer(id: ID!): EventOrganizerReferrer

  """イベント主催者紹介者を複数取得する"""
  eventOrganizerReferrers(after: String, before: String, first: Int, last: Int, orderBy: [EventOrganizerReferrerOrderByWithRelationInput!], where: EventOrganizerReferrerWhereInput): EventOrganizerReferrerConnection!

  """イベント主催者を複数取得する"""
  eventOrganizers(after: String, before: String, first: Int, last: Int, orderBy: [EventOrganizerOrderByWithRelationInput!], where: EventOrganizerWhereInput): EventOrganizerConnection!

  """イベントを複数取得する"""
  events(after: String, before: String, first: Int, last: Int, orderBy: [EventOrderByWithRelationInput!], where: EventWhereInput): EventConnection!

  """特集イベントを1件取得する"""
  featuredEvent(id: ID!): FeaturedEvent

  """特集イベントを複数取得する"""
  featuredEvents(after: String, before: String, first: Int, last: Int, orderBy: [FeaturedEventOrderByWithRelationInput!], where: FeaturedEventWhereInput): FeaturedEventConnection!

  """支払いを1件取得する"""
  payment(id: ID!): Payment

  """支払いカードを1件取得する"""
  paymentCard(id: ID!): PaymentCard

  """支払いカードを複数取得する"""
  paymentCards(after: String, before: String, first: Int, last: Int, orderBy: [PaymentCardOrderByWithRelationInput!], where: PaymentCardWhereInput): PaymentCardConnection!

  """支払いアイテムを1件取得する"""
  paymentItem(id: ID!): PaymentItem

  """支払いアイテムを複数取得する"""
  paymentItems(after: String, before: String, first: Int, last: Int, orderBy: [PaymentItemOrderByWithRelationInput!], where: PaymentItemWhereInput): PaymentItemConnection!

  """支払いを複数取得する"""
  payments(after: String, before: String, first: Int, last: Int, orderBy: [PaymentOrderByWithRelationInput!], where: PaymentWhereInput): PaymentConnection!

  """販売スケジュールを1件取得する"""
  saleSchedule(id: ID!): SaleSchedule

  """販売スケジュールを複数取得する"""
  saleSchedules(after: String, before: String, first: Int, last: Int, orderBy: [SaleScheduleOrderByWithRelationInput!], where: SaleScheduleWhereInput): SaleScheduleConnection!

  """セッションを1件取得する"""
  session(id: ID!): Session

  """セッションを複数取得する"""
  sessions(after: String, before: String, first: Int, last: Int, orderBy: [SessionOrderByWithRelationInput!], where: SessionWhereInput): SessionConnection!

  """ステージを1件取得する"""
  stage(id: ID!): Stage

  """ステージを複数取得する"""
  stages(after: String, before: String, first: Int, last: Int, orderBy: [StageOrderByWithRelationInput!], where: StageWhereInput): StageConnection!

  """チケットを1件取得する"""
  ticket(id: ID!): Ticket

  """チケット申し込みを1件取得する"""
  ticketApplication(id: ID!): TicketApplication

  """チケット申し込みアイテムを1件取得する"""
  ticketApplicationItem(id: ID!): TicketApplicationItem

  """チケット申し込みアイテムを複数取得する"""
  ticketApplicationItems(after: String, before: String, first: Int, last: Int, orderBy: [TicketApplicationItemOrderByWithRelationInput!], where: TicketApplicationItemWhereInput): TicketApplicationItemConnection!

  """チケット申し込みを複数取得する"""
  ticketApplications(after: String, before: String, first: Int, last: Int, orderBy: [TicketApplicationOrderByWithRelationInput!], where: TicketApplicationWhereInput): TicketApplicationConnection!

  """チケットタイプを1件取得する"""
  ticketType(id: ID!): TicketType

  """チケットタイプ手数料を1件取得する"""
  ticketTypeFee(id: ID!): TicketTypeFee

  """チケットタイプ手数料を複数取得する"""
  ticketTypeFees(after: String, before: String, first: Int, last: Int, orderBy: [TicketTypeFeeOrderByWithRelationInput!], where: TicketTypeFeeWhereInput): TicketTypeFeeConnection!

  """チケットタイプを複数取得する"""
  ticketTypes(after: String, before: String, first: Int, last: Int, orderBy: [TicketTypeOrderByWithRelationInput!], where: TicketTypeWhereInput): TicketTypeConnection!

  """チケットを複数取得する"""
  tickets(after: String, before: String, first: Int, last: Int, orderBy: [TicketOrderByWithRelationInput!], where: TicketWhereInput): TicketConnection!

  """[Shared]: Userを取得する"""
  user(id: ID): User

  """ユーザー制限を1件取得する"""
  userRestriction(id: ID!): UserRestriction

  """ユーザー制限を複数取得する"""
  userRestrictions(after: String, before: String, first: Int, last: Int, orderBy: [UserRestrictionOrderByWithRelationInput!], where: UserRestrictionWhereInput): UserRestrictionConnection!

  """[Admin]:Userを複数取得する"""
  users(after: String, before: String, first: Int, last: Int, orderBy: [UserOrderByWithRelationInput!], where: UserWhereInput): UserConnection!

  """会場を1件取得する"""
  venue(id: ID!): Venue

  """会場を複数取得する"""
  venues(after: String, before: String, first: Int, last: Int, orderBy: [VenueOrderByWithRelationInput!], where: VenueWhereInput): VenueConnection!

  """認証情報を1件取得する"""
  verification(id: ID!): Verification

  """認証情報を複数取得する"""
  verifications(after: String, before: String, first: Int, last: Int, orderBy: [VerificationOrderByWithRelationInput!], where: VerificationWhereInput): VerificationConnection!
}

enum QueryMode {
  default
  insensitive
}

type SaleSchedule {
  availablePaymentMethods: [AvailablePaymentMethod!]
  createdAt: DateTime!
  deletedAt: DateTime
  description: String!
  event: Event!
  eventId: String!
  id: ID!
  isDuplicatePurchaseAllowed: Boolean!
  isFanClubOnly: Boolean!
  isResale: Boolean!
  isSmsAuthRequired: Boolean!
  isTransferRequired: Boolean!
  konbiniPaymentTermDay: Int
  lotteryMode: LotteryMode
  lotteryResultAnnounceAt: DateTime
  lotteryStartAt: DateTime
  maxApplicationCount: Int
  maxPerApplication: Int!
  name: String!
  paperTicketExchangeEndAt: DateTime
  paperTicketExchangeStartAt: DateTime
  publishAt: DateTime!
  publishStatus: SaleSchedulePublishStatus!
  reservedSeatTicketIssueAt: DateTime
  saleEndAt: DateTime!
  saleStartAt: DateTime!
  saleType: SaleType!
  sortOrder: Int!
  ticketTypes: [TicketType!]
  transferPolicy: TicketTransferPolicy!
  updatedAt: DateTime!
}

type SaleScheduleConnection {
  edges: [SaleScheduleEdge!]!
  nodes: [SaleSchedule!]!
  pageInfo: SaleSchedulePageInfo!
  totalCount: Int!
}

input SaleScheduleCreateInput {
  description: String!
  eventId: ID!
  isSmsAuthRequired: Boolean = false
  lotteryMode: LotteryMode
  lotteryResultAnnounceAt: DateTime
  lotteryStartAt: DateTime
  name: String!
  publishAt: DateTime!
  saleEndAt: DateTime!
  saleStartAt: DateTime!
  saleType: SaleType!
}

type SaleScheduleCreatePayload {
  saleSchedule: SaleSchedule!
}

type SaleScheduleEdge {
  cursor: String!
  node: SaleSchedule!
}

input SaleScheduleListRelationFilter {
  every: SaleScheduleWhereInput
  none: SaleScheduleWhereInput
  some: SaleScheduleWhereInput
}

input SaleScheduleOrderByRelationAggregateInput {
  _count: SortOrder
}

input SaleScheduleOrderByWithRelationInput {
  availablePaymentMethods: AvailablePaymentMethodOrderByRelationAggregateInput
  createdAt: SortOrder
  deletedAt: SortOrderInput
  description: SortOrder
  event: EventOrderByWithRelationInput
  eventId: SortOrder
  id: SortOrder
  isDuplicatePurchaseAllowed: SortOrder
  isFanClubOnly: SortOrder
  isResale: SortOrder
  isSmsAuthRequired: SortOrder
  isTransferRequired: SortOrder
  konbiniPaymentTermDay: SortOrderInput
  lotteryMode: SortOrderInput
  lotteryResultAnnounceAt: SortOrderInput
  lotteryStartAt: SortOrderInput
  maxApplicationCount: SortOrderInput
  maxPerApplication: SortOrder
  name: SortOrder
  paperTicketExchangeEndAt: SortOrderInput
  paperTicketExchangeStartAt: SortOrderInput
  publishAt: SortOrder
  publishStatus: SortOrder
  reservedSeatTicketIssueAt: SortOrderInput
  saleEndAt: SortOrder
  saleStartAt: SortOrder
  saleType: SortOrder
  sortOrder: SortOrder
  ticketTypes: TicketTypeOrderByRelationAggregateInput
  transferPolicy: SortOrder
  updatedAt: SortOrder
}

type SaleSchedulePageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

enum SaleSchedulePublishStatus {
  PUBLISHED
  UNPUBLISHED
}

input SaleScheduleScalarRelationFilter {
  is: SaleScheduleWhereInput
  isNot: SaleScheduleWhereInput
}

input SaleScheduleUpdateInput {
  description: String
  id: ID!
  isSmsAuthRequired: Boolean
  lotteryMode: LotteryMode
  lotteryResultAnnounceAt: DateTime
  lotteryStartAt: DateTime
  name: String
  publishAt: DateTime
  saleEndAt: DateTime
  saleStartAt: DateTime
  saleType: SaleType
}

type SaleScheduleUpdatePayload {
  saleSchedule: SaleSchedule!
}

input SaleScheduleWhereInput {
  AND: [SaleScheduleWhereInput!]
  NOT: [SaleScheduleWhereInput!]
  OR: [SaleScheduleWhereInput!]
  availablePaymentMethods: AvailablePaymentMethodListRelationFilter
  createdAt: DateTimeFilter
  deletedAt: DateTimeNullableFilter
  description: StringFilter
  event: EventScalarRelationFilter
  eventId: StringFilter
  id: StringFilter
  isDuplicatePurchaseAllowed: BoolFilter
  isFanClubOnly: BoolFilter
  isResale: BoolFilter
  isSmsAuthRequired: BoolFilter
  isTransferRequired: BoolFilter
  konbiniPaymentTermDay: IntNullableFilter
  lotteryMode: EnumLotteryModeNullableFilter
  lotteryResultAnnounceAt: DateTimeNullableFilter
  lotteryStartAt: DateTimeNullableFilter
  maxApplicationCount: IntNullableFilter
  maxPerApplication: IntFilter
  name: StringFilter
  paperTicketExchangeEndAt: DateTimeNullableFilter
  paperTicketExchangeStartAt: DateTimeNullableFilter
  publishAt: DateTimeFilter
  publishStatus: EnumSaleSchedulePublishStatusFilter
  reservedSeatTicketIssueAt: DateTimeNullableFilter
  saleEndAt: DateTimeFilter
  saleStartAt: DateTimeFilter
  saleType: EnumSaleTypeFilter
  sortOrder: IntFilter
  ticketTypes: TicketTypeListRelationFilter
  transferPolicy: EnumTicketTransferPolicyFilter
  updatedAt: DateTimeFilter
}

enum SaleType {
  FIRST_COME
  LOTTERY
}

enum SeatType {
  ENTRY_NUMBER
  FREE
  RESERVED
}

type Session {
  createdAt: DateTime!
  expiresAt: DateTime!
  id: ID!
  ipAddress: String
  token: String!
  updatedAt: DateTime!
  user: User!
  userAgent: String
  userId: String!
}

type SessionConnection {
  edges: [SessionEdge!]!
  nodes: [Session!]!
  pageInfo: SessionPageInfo!
  totalCount: Int!
}

type SessionEdge {
  cursor: String!
  node: Session!
}

input SessionListRelationFilter {
  every: SessionWhereInput
  none: SessionWhereInput
  some: SessionWhereInput
}

input SessionOrderByRelationAggregateInput {
  _count: SortOrder
}

input SessionOrderByWithRelationInput {
  createdAt: SortOrder
  expiresAt: SortOrder
  id: SortOrder
  ipAddress: SortOrderInput
  token: SortOrder
  updatedAt: SortOrder
  user: UserOrderByWithRelationInput
  userAgent: SortOrderInput
  userId: SortOrder
}

type SessionPageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

input SessionWhereInput {
  AND: [SessionWhereInput!]
  NOT: [SessionWhereInput!]
  OR: [SessionWhereInput!]
  createdAt: DateTimeFilter
  expiresAt: DateTimeFilter
  id: StringFilter
  ipAddress: StringNullableFilter
  token: StringFilter
  updatedAt: DateTimeFilter
  user: UserScalarRelationFilter
  userAgent: StringNullableFilter
  userId: StringFilter
}

enum SortOrder {
  asc
  desc
}

input SortOrderInput {
  nulls: NullsOrder
  sort: SortOrder!
}

type Stage {
  createdAt: DateTime!
  doorsOpenAt: DateTime!
  event: Event!
  eventId: String!
  id: ID!
  name: String!
  stageArtists: [StageArtist!]
  stageTicketTypes: [StageTicketType!]
  startAt: DateTime!
  updatedAt: DateTime!
  venue: Venue
  venueId: String
}

type StageArtist {
  artist: Artist!
  artistId: String!
  createdAt: DateTime!
  sortOrder: Int!
  stage: Stage!
  stageId: String!
  updatedAt: DateTime!
}

input StageArtistListRelationFilter {
  every: StageArtistWhereInput
  none: StageArtistWhereInput
  some: StageArtistWhereInput
}

input StageArtistOrderByRelationAggregateInput {
  _count: SortOrder
}

input StageArtistWhereInput {
  AND: [StageArtistWhereInput!]
  NOT: [StageArtistWhereInput!]
  OR: [StageArtistWhereInput!]
  artist: ArtistScalarRelationFilter
  artistId: StringFilter
  createdAt: DateTimeFilter
  sortOrder: IntFilter
  stage: StageScalarRelationFilter
  stageId: StringFilter
  updatedAt: DateTimeFilter
}

type StageConnection {
  edges: [StageEdge!]!
  nodes: [Stage!]!
  pageInfo: StagePageInfo!
  totalCount: Int!
}

type StageEdge {
  cursor: String!
  node: Stage!
}

input StageInput {
  artistNames: [String!]!
  doorsOpenAt: DateTime!
  name: String!
  startAt: DateTime!
  venueName: String!
}

input StageListRelationFilter {
  every: StageWhereInput
  none: StageWhereInput
  some: StageWhereInput
}

input StageOrderByRelationAggregateInput {
  _count: SortOrder
}

input StageOrderByWithRelationInput {
  createdAt: SortOrder
  doorsOpenAt: SortOrder
  event: EventOrderByWithRelationInput
  eventId: SortOrder
  id: SortOrder
  name: SortOrder
  stageArtists: StageArtistOrderByRelationAggregateInput
  stageTicketTypes: StageTicketTypeOrderByRelationAggregateInput
  startAt: SortOrder
  updatedAt: SortOrder
  venue: VenueOrderByWithRelationInput
  venueId: SortOrderInput
}

type StagePageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

input StageScalarRelationFilter {
  is: StageWhereInput
  isNot: StageWhereInput
}

type StageTicketType {
  createdAt: DateTime!
  stage: Stage!
  stageId: String!
  ticketType: TicketType!
  ticketTypeId: String!
  updatedAt: DateTime!
}

input StageTicketTypeListRelationFilter {
  every: StageTicketTypeWhereInput
  none: StageTicketTypeWhereInput
  some: StageTicketTypeWhereInput
}

input StageTicketTypeOrderByRelationAggregateInput {
  _count: SortOrder
}

input StageTicketTypeWhereInput {
  AND: [StageTicketTypeWhereInput!]
  NOT: [StageTicketTypeWhereInput!]
  OR: [StageTicketTypeWhereInput!]
  createdAt: DateTimeFilter
  stage: StageScalarRelationFilter
  stageId: StringFilter
  ticketType: TicketTypeScalarRelationFilter
  ticketTypeId: StringFilter
  updatedAt: DateTimeFilter
}

input StageUpdateInput {
  artistNames: [String!]
  doorsOpenAt: DateTime
  name: String
  startAt: DateTime
  venueName: String
}

input StageWhereInput {
  AND: [StageWhereInput!]
  NOT: [StageWhereInput!]
  OR: [StageWhereInput!]
  createdAt: DateTimeFilter
  doorsOpenAt: DateTimeFilter
  event: EventScalarRelationFilter
  eventId: StringFilter
  id: StringFilter
  name: StringFilter
  stageArtists: StageArtistListRelationFilter
  stageTicketTypes: StageTicketTypeListRelationFilter
  startAt: DateTimeFilter
  updatedAt: DateTimeFilter
  venue: VenueNullableScalarRelationFilter
  venueId: StringNullableFilter
}

input StagesUpdateInput {
  eventId: ID!
  stages: [StageUpdateInput!]!
}

type StagesUpdatePayload {
  event: Event!
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableListFilter {
  equals: [String!]
  has: String
  hasEvery: [String!]
  hasSome: [String!]
  isEmpty: Boolean
}

type Ticket {
  createdAt: DateTime!
  id: ID!
  method: AdmissionMethod!
  name: String!
  ticketApplicationItem: TicketApplicationItem!
  ticketApplicationItemId: String!
  ticketType: TicketType!
  ticketTypeId: String!
  updatedAt: DateTime!
  user: User!
  userId: String!
}

type TicketApplication {
  cancelReason: String
  cancelledAt: DateTime
  createdAt: DateTime!
  id: ID!
  payments: [Payment!]
  status: TicketApplicationStatus!
  ticketApplicationItems: [TicketApplicationItem!]
  updatedAt: DateTime!
  user: User!
  userId: String!
}

type TicketApplicationConnection {
  edges: [TicketApplicationEdge!]!
  nodes: [TicketApplication!]!
  pageInfo: TicketApplicationPageInfo!
  totalCount: Int!
}

type TicketApplicationEdge {
  cursor: String!
  node: TicketApplication!
}

type TicketApplicationItem {
  createdAt: DateTime!
  id: ID!
  paymentItems: [PaymentItem!]
  priority: Int!
  quantity: Int!
  ticketApplication: TicketApplication!
  ticketApplicationId: String!
  ticketType: TicketType!
  ticketTypeId: String!
  tickets: [Ticket!]
  updatedAt: DateTime!
}

type TicketApplicationItemConnection {
  edges: [TicketApplicationItemEdge!]!
  nodes: [TicketApplicationItem!]!
  pageInfo: TicketApplicationItemPageInfo!
  totalCount: Int!
}

type TicketApplicationItemEdge {
  cursor: String!
  node: TicketApplicationItem!
}

input TicketApplicationItemListRelationFilter {
  every: TicketApplicationItemWhereInput
  none: TicketApplicationItemWhereInput
  some: TicketApplicationItemWhereInput
}

input TicketApplicationItemOrderByRelationAggregateInput {
  _count: SortOrder
}

input TicketApplicationItemOrderByWithRelationInput {
  createdAt: SortOrder
  id: SortOrder
  paymentItems: PaymentItemOrderByRelationAggregateInput
  priority: SortOrder
  quantity: SortOrder
  ticketApplication: TicketApplicationOrderByWithRelationInput
  ticketApplicationId: SortOrder
  ticketType: TicketTypeOrderByWithRelationInput
  ticketTypeId: SortOrder
  tickets: TicketOrderByRelationAggregateInput
  updatedAt: SortOrder
}

type TicketApplicationItemPageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

input TicketApplicationItemScalarRelationFilter {
  is: TicketApplicationItemWhereInput
  isNot: TicketApplicationItemWhereInput
}

input TicketApplicationItemWhereInput {
  AND: [TicketApplicationItemWhereInput!]
  NOT: [TicketApplicationItemWhereInput!]
  OR: [TicketApplicationItemWhereInput!]
  createdAt: DateTimeFilter
  id: StringFilter
  paymentItems: PaymentItemListRelationFilter
  priority: IntFilter
  quantity: IntFilter
  ticketApplication: TicketApplicationScalarRelationFilter
  ticketApplicationId: StringFilter
  ticketType: TicketTypeScalarRelationFilter
  ticketTypeId: StringFilter
  tickets: TicketListRelationFilter
  updatedAt: DateTimeFilter
}

input TicketApplicationListRelationFilter {
  every: TicketApplicationWhereInput
  none: TicketApplicationWhereInput
  some: TicketApplicationWhereInput
}

input TicketApplicationOrderByRelationAggregateInput {
  _count: SortOrder
}

input TicketApplicationOrderByWithRelationInput {
  cancelReason: SortOrderInput
  cancelledAt: SortOrderInput
  createdAt: SortOrder
  id: SortOrder
  payments: PaymentOrderByRelationAggregateInput
  status: SortOrder
  ticketApplicationItems: TicketApplicationItemOrderByRelationAggregateInput
  updatedAt: SortOrder
  user: UserOrderByWithRelationInput
  userId: SortOrder
}

type TicketApplicationPageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

input TicketApplicationScalarRelationFilter {
  is: TicketApplicationWhereInput
  isNot: TicketApplicationWhereInput
}

enum TicketApplicationStatus {
  CANCELLED
  LOST
  PENDING
  WIN
}

input TicketApplicationWhereInput {
  AND: [TicketApplicationWhereInput!]
  NOT: [TicketApplicationWhereInput!]
  OR: [TicketApplicationWhereInput!]
  cancelReason: StringNullableFilter
  cancelledAt: DateTimeNullableFilter
  createdAt: DateTimeFilter
  id: StringFilter
  payments: PaymentListRelationFilter
  status: EnumTicketApplicationStatusFilter
  ticketApplicationItems: TicketApplicationItemListRelationFilter
  updatedAt: DateTimeFilter
  user: UserScalarRelationFilter
  userId: StringFilter
}

type TicketConnection {
  edges: [TicketEdge!]!
  nodes: [Ticket!]!
  pageInfo: TicketPageInfo!
  totalCount: Int!
}

type TicketEdge {
  cursor: String!
  node: Ticket!
}

input TicketListRelationFilter {
  every: TicketWhereInput
  none: TicketWhereInput
  some: TicketWhereInput
}

input TicketOrderByRelationAggregateInput {
  _count: SortOrder
}

input TicketOrderByWithRelationInput {
  createdAt: SortOrder
  id: SortOrder
  method: SortOrder
  name: SortOrder
  ticketApplicationItem: TicketApplicationItemOrderByWithRelationInput
  ticketApplicationItemId: SortOrder
  ticketType: TicketTypeOrderByWithRelationInput
  ticketTypeId: SortOrder
  updatedAt: SortOrder
  user: UserOrderByWithRelationInput
  userId: SortOrder
}

type TicketPageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

enum TicketTransferPolicy {
  COMPANIONS_ONLY
  FREE
  NOT_ALLOWED
  REGISTERED_COMPANIONS_ONLY
}

type TicketType {
  basePrice: Int!
  capacity: Int!
  createdAt: DateTime!
  description: String!
  id: ID!
  isOnceApplyOnly: Boolean!
  isOnlyQrCodeEntry: Boolean!
  maxNumPerApply: Int!
  name: String!
  saleSchedule: SaleSchedule!
  saleScheduleId: String!
  seatType: SeatType!
  sortOrder: Int!
  stageTicketTypes: [StageTicketType!]
  ticketApplicationItems: [TicketApplicationItem!]
  ticketTypeFees: [TicketTypeFee!]
  ticketTypePriceDistributions: [TicketTypePriceDistribution!]
  tickets: [Ticket!]
  updatedAt: DateTime!
}

type TicketTypeConnection {
  edges: [TicketTypeEdge!]!
  nodes: [TicketType!]!
  pageInfo: TicketTypePageInfo!
  totalCount: Int!
}

type TicketTypeEdge {
  cursor: String!
  node: TicketType!
}

type TicketTypeFee {
  amount: Int!
  createdAt: DateTime!
  id: ID!
  name: String!
  ticketType: TicketType!
  ticketTypeFeeDistributions: [TicketTypeFeeDistribution!]
  ticketTypeId: String!
  updatedAt: DateTime!
}

type TicketTypeFeeConnection {
  edges: [TicketTypeFeeEdge!]!
  nodes: [TicketTypeFee!]!
  pageInfo: TicketTypeFeePageInfo!
  totalCount: Int!
}

type TicketTypeFeeDistribution {
  amount: Int!
  createdAt: DateTime!
  eventOrganizer: EventOrganizer!
  eventOrganizerId: String!
  ticketTypeFee: TicketTypeFee!
  ticketTypeFeeId: String!
  updatedAt: DateTime!
}

input TicketTypeFeeDistributionListRelationFilter {
  every: TicketTypeFeeDistributionWhereInput
  none: TicketTypeFeeDistributionWhereInput
  some: TicketTypeFeeDistributionWhereInput
}

input TicketTypeFeeDistributionOrderByRelationAggregateInput {
  _count: SortOrder
}

input TicketTypeFeeDistributionWhereInput {
  AND: [TicketTypeFeeDistributionWhereInput!]
  NOT: [TicketTypeFeeDistributionWhereInput!]
  OR: [TicketTypeFeeDistributionWhereInput!]
  amount: IntFilter
  createdAt: DateTimeFilter
  eventOrganizer: EventOrganizerScalarRelationFilter
  eventOrganizerId: StringFilter
  ticketTypeFee: TicketTypeFeeScalarRelationFilter
  ticketTypeFeeId: StringFilter
  updatedAt: DateTimeFilter
}

type TicketTypeFeeEdge {
  cursor: String!
  node: TicketTypeFee!
}

input TicketTypeFeeListRelationFilter {
  every: TicketTypeFeeWhereInput
  none: TicketTypeFeeWhereInput
  some: TicketTypeFeeWhereInput
}

input TicketTypeFeeOrderByRelationAggregateInput {
  _count: SortOrder
}

input TicketTypeFeeOrderByWithRelationInput {
  amount: SortOrder
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  ticketType: TicketTypeOrderByWithRelationInput
  ticketTypeFeeDistributions: TicketTypeFeeDistributionOrderByRelationAggregateInput
  ticketTypeId: SortOrder
  updatedAt: SortOrder
}

type TicketTypeFeePageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

input TicketTypeFeeScalarRelationFilter {
  is: TicketTypeFeeWhereInput
  isNot: TicketTypeFeeWhereInput
}

input TicketTypeFeeWhereInput {
  AND: [TicketTypeFeeWhereInput!]
  NOT: [TicketTypeFeeWhereInput!]
  OR: [TicketTypeFeeWhereInput!]
  amount: IntFilter
  createdAt: DateTimeFilter
  id: StringFilter
  name: StringFilter
  ticketType: TicketTypeScalarRelationFilter
  ticketTypeFeeDistributions: TicketTypeFeeDistributionListRelationFilter
  ticketTypeId: StringFilter
  updatedAt: DateTimeFilter
}

input TicketTypeListRelationFilter {
  every: TicketTypeWhereInput
  none: TicketTypeWhereInput
  some: TicketTypeWhereInput
}

input TicketTypeOrderByRelationAggregateInput {
  _count: SortOrder
}

input TicketTypeOrderByWithRelationInput {
  basePrice: SortOrder
  capacity: SortOrder
  createdAt: SortOrder
  description: SortOrder
  id: SortOrder
  isOnceApplyOnly: SortOrder
  isOnlyQrCodeEntry: SortOrder
  maxNumPerApply: SortOrder
  name: SortOrder
  saleSchedule: SaleScheduleOrderByWithRelationInput
  saleScheduleId: SortOrder
  seatType: SortOrder
  sortOrder: SortOrder
  stageTicketTypes: StageTicketTypeOrderByRelationAggregateInput
  ticketApplicationItems: TicketApplicationItemOrderByRelationAggregateInput
  ticketTypeFees: TicketTypeFeeOrderByRelationAggregateInput
  ticketTypePriceDistributions: TicketTypePriceDistributionOrderByRelationAggregateInput
  tickets: TicketOrderByRelationAggregateInput
  updatedAt: SortOrder
}

type TicketTypePageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

type TicketTypePriceDistribution {
  amount: Int!
  createdAt: DateTime!
  eventOrganizer: EventOrganizer!
  eventOrganizerId: String!
  ticketType: TicketType!
  ticketTypeId: String!
  updatedAt: DateTime!
}

input TicketTypePriceDistributionListRelationFilter {
  every: TicketTypePriceDistributionWhereInput
  none: TicketTypePriceDistributionWhereInput
  some: TicketTypePriceDistributionWhereInput
}

input TicketTypePriceDistributionOrderByRelationAggregateInput {
  _count: SortOrder
}

input TicketTypePriceDistributionWhereInput {
  AND: [TicketTypePriceDistributionWhereInput!]
  NOT: [TicketTypePriceDistributionWhereInput!]
  OR: [TicketTypePriceDistributionWhereInput!]
  amount: IntFilter
  createdAt: DateTimeFilter
  eventOrganizer: EventOrganizerScalarRelationFilter
  eventOrganizerId: StringFilter
  ticketType: TicketTypeScalarRelationFilter
  ticketTypeId: StringFilter
  updatedAt: DateTimeFilter
}

input TicketTypeScalarRelationFilter {
  is: TicketTypeWhereInput
  isNot: TicketTypeWhereInput
}

input TicketTypeUpdateInput {
  basePrice: Int
  capacity: Int
  description: String
  id: ID!
  isOnceApplyOnly: Boolean
  isOnlyQrCodeEntry: Boolean
  maxNumPerApply: Int
  name: String
  seatType: SeatType
  sortOrder: Int
}

type TicketTypeUpdatePayload {
  ticketType: TicketType!
}

input TicketTypeWhereInput {
  AND: [TicketTypeWhereInput!]
  NOT: [TicketTypeWhereInput!]
  OR: [TicketTypeWhereInput!]
  basePrice: IntFilter
  capacity: IntFilter
  createdAt: DateTimeFilter
  description: StringFilter
  id: StringFilter
  isOnceApplyOnly: BoolFilter
  isOnlyQrCodeEntry: BoolFilter
  maxNumPerApply: IntFilter
  name: StringFilter
  saleSchedule: SaleScheduleScalarRelationFilter
  saleScheduleId: StringFilter
  seatType: EnumSeatTypeFilter
  sortOrder: IntFilter
  stageTicketTypes: StageTicketTypeListRelationFilter
  ticketApplicationItems: TicketApplicationItemListRelationFilter
  ticketTypeFees: TicketTypeFeeListRelationFilter
  ticketTypePriceDistributions: TicketTypePriceDistributionListRelationFilter
  tickets: TicketListRelationFilter
  updatedAt: DateTimeFilter
}

input TicketWhereInput {
  AND: [TicketWhereInput!]
  NOT: [TicketWhereInput!]
  OR: [TicketWhereInput!]
  createdAt: DateTimeFilter
  id: StringFilter
  method: EnumAdmissionMethodFilter
  name: StringFilter
  ticketApplicationItem: TicketApplicationItemScalarRelationFilter
  ticketApplicationItemId: StringFilter
  ticketType: TicketTypeScalarRelationFilter
  ticketTypeId: StringFilter
  updatedAt: DateTimeFilter
  user: UserScalarRelationFilter
  userId: StringFilter
}

type User {
  accounts: [Account!]
  createdAt: DateTime!
  email: String!
  emailVerified: Boolean!
  eventOrganizers: [EventOrganizer!]
  favoriteArtists: [FavoriteArtist!]
  favoriteEvents: [FavoriteEvent!]
  id: ID!
  image: String
  name: String!
  paymentCards: [PaymentCard!]
  role: UserRole!
  sessions: [Session!]
  ticketApplications: [TicketApplication!]
  tickets: [Ticket!]
  updatedAt: DateTime!
  userRestrictions: [UserRestriction!]
}

type UserConnection {
  edges: [UserEdge!]!
  nodes: [User!]!
  pageInfo: UserPageInfo!
  totalCount: Int!
}

type UserEdge {
  cursor: String!
  node: User!
}

input UserOrderByWithRelationInput {
  accounts: AccountOrderByRelationAggregateInput
  createdAt: SortOrder
  email: SortOrder
  emailVerified: SortOrder
  eventOrganizers: EventOrganizerOrderByRelationAggregateInput
  favoriteArtists: FavoriteArtistOrderByRelationAggregateInput
  favoriteEvents: FavoriteEventOrderByRelationAggregateInput
  id: SortOrder
  image: SortOrderInput
  name: SortOrder
  paymentCards: PaymentCardOrderByRelationAggregateInput
  role: SortOrder
  sessions: SessionOrderByRelationAggregateInput
  ticketApplications: TicketApplicationOrderByRelationAggregateInput
  tickets: TicketOrderByRelationAggregateInput
  updatedAt: SortOrder
  userRestrictions: UserRestrictionOrderByRelationAggregateInput
}

type UserPageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

type UserRestriction {
  createdAt: DateTime!
  expiresAt: DateTime
  id: ID!
  reason: String!
  updatedAt: DateTime!
  user: User!
  userId: String!
}

type UserRestrictionConnection {
  edges: [UserRestrictionEdge!]!
  nodes: [UserRestriction!]!
  pageInfo: UserRestrictionPageInfo!
  totalCount: Int!
}

type UserRestrictionEdge {
  cursor: String!
  node: UserRestriction!
}

input UserRestrictionListRelationFilter {
  every: UserRestrictionWhereInput
  none: UserRestrictionWhereInput
  some: UserRestrictionWhereInput
}

input UserRestrictionOrderByRelationAggregateInput {
  _count: SortOrder
}

input UserRestrictionOrderByWithRelationInput {
  createdAt: SortOrder
  expiresAt: SortOrderInput
  id: SortOrder
  reason: SortOrder
  updatedAt: SortOrder
  user: UserOrderByWithRelationInput
  userId: SortOrder
}

type UserRestrictionPageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

input UserRestrictionWhereInput {
  AND: [UserRestrictionWhereInput!]
  NOT: [UserRestrictionWhereInput!]
  OR: [UserRestrictionWhereInput!]
  createdAt: DateTimeFilter
  expiresAt: DateTimeNullableFilter
  id: StringFilter
  reason: StringFilter
  updatedAt: DateTimeFilter
  user: UserScalarRelationFilter
  userId: StringFilter
}

enum UserRole {
  EVENT_ORGANIZER
  PLATFORM_MANAGER
  TICKET_PURCHASER
}

input UserScalarRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

input UserWhereInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  accounts: AccountListRelationFilter
  createdAt: DateTimeFilter
  email: StringFilter
  emailVerified: BoolFilter
  eventOrganizers: EventOrganizerListRelationFilter
  favoriteArtists: FavoriteArtistListRelationFilter
  favoriteEvents: FavoriteEventListRelationFilter
  id: StringFilter
  image: StringNullableFilter
  name: StringFilter
  paymentCards: PaymentCardListRelationFilter
  role: EnumUserRoleFilter
  sessions: SessionListRelationFilter
  ticketApplications: TicketApplicationListRelationFilter
  tickets: TicketListRelationFilter
  updatedAt: DateTimeFilter
  userRestrictions: UserRestrictionListRelationFilter
}

type Venue {
  createdAt: DateTime!
  id: ID!
  name: String!
  stages: [Stage!]
  updatedAt: DateTime!
}

type VenueConnection {
  edges: [VenueEdge!]!
  nodes: [Venue!]!
  pageInfo: VenuePageInfo!
  totalCount: Int!
}

type VenueEdge {
  cursor: String!
  node: Venue!
}

input VenueNullableScalarRelationFilter {
  is: VenueWhereInput
  isNot: VenueWhereInput
}

input VenueOrderByWithRelationInput {
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  stages: StageOrderByRelationAggregateInput
  updatedAt: SortOrder
}

type VenuePageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

input VenueWhereInput {
  AND: [VenueWhereInput!]
  NOT: [VenueWhereInput!]
  OR: [VenueWhereInput!]
  createdAt: DateTimeFilter
  id: StringFilter
  name: StringFilter
  stages: StageListRelationFilter
  updatedAt: DateTimeFilter
}

type Verification {
  createdAt: DateTime!
  expiresAt: DateTime!
  id: ID!
  identifier: String!
  updatedAt: DateTime!
  value: String!
}

type VerificationConnection {
  edges: [VerificationEdge!]!
  nodes: [Verification!]!
  pageInfo: VerificationPageInfo!
  totalCount: Int!
}

type VerificationEdge {
  cursor: String!
  node: Verification!
}

input VerificationOrderByWithRelationInput {
  createdAt: SortOrder
  expiresAt: SortOrder
  id: SortOrder
  identifier: SortOrder
  updatedAt: SortOrder
  value: SortOrder
}

type VerificationPageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

input VerificationWhereInput {
  AND: [VerificationWhereInput!]
  NOT: [VerificationWhereInput!]
  OR: [VerificationWhereInput!]
  createdAt: DateTimeFilter
  expiresAt: DateTimeFilter
  id: StringFilter
  identifier: StringFilter
  updatedAt: DateTimeFilter
  value: StringFilter
}